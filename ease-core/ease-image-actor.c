/* ease-image-actor.c generated by valac 0.10.0, the Vala compiler
 * generated from ease-image-actor.vala, do not modify */

/*  Ease, a GTK presentation application
    Copyright (C) 2010 Nate Stedman

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include <glib.h>
#include <glib-object.h>
#include <clutter/clutter.h>
#include <gtk/gtk.h>
#include <float.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <glib/gi18n-lib.h>


#define EASE_TYPE_ACTOR (ease_actor_get_type ())
#define EASE_ACTOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EASE_TYPE_ACTOR, EaseActor))
#define EASE_ACTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EASE_TYPE_ACTOR, EaseActorClass))
#define EASE_IS_ACTOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EASE_TYPE_ACTOR))
#define EASE_IS_ACTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EASE_TYPE_ACTOR))
#define EASE_ACTOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EASE_TYPE_ACTOR, EaseActorClass))

typedef struct _EaseActor EaseActor;
typedef struct _EaseActorClass EaseActorClass;
typedef struct _EaseActorPrivate EaseActorPrivate;

#define EASE_TYPE_ELEMENT (ease_element_get_type ())
#define EASE_ELEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EASE_TYPE_ELEMENT, EaseElement))
#define EASE_ELEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EASE_TYPE_ELEMENT, EaseElementClass))
#define EASE_IS_ELEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EASE_TYPE_ELEMENT))
#define EASE_IS_ELEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EASE_TYPE_ELEMENT))
#define EASE_ELEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EASE_TYPE_ELEMENT, EaseElementClass))

typedef struct _EaseElement EaseElement;
typedef struct _EaseElementClass EaseElementClass;

#define EASE_TYPE_ACTOR_CONTEXT (ease_actor_context_get_type ())

#define EASE_TYPE_IMAGE_ACTOR (ease_image_actor_get_type ())
#define EASE_IMAGE_ACTOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EASE_TYPE_IMAGE_ACTOR, EaseImageActor))
#define EASE_IMAGE_ACTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EASE_TYPE_IMAGE_ACTOR, EaseImageActorClass))
#define EASE_IS_IMAGE_ACTOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EASE_TYPE_IMAGE_ACTOR))
#define EASE_IS_IMAGE_ACTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EASE_TYPE_IMAGE_ACTOR))
#define EASE_IMAGE_ACTOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EASE_TYPE_IMAGE_ACTOR, EaseImageActorClass))

typedef struct _EaseImageActor EaseImageActor;
typedef struct _EaseImageActorClass EaseImageActorClass;
typedef struct _EaseImageActorPrivate EaseImageActorPrivate;

#define EASE_TYPE_MEDIA_ELEMENT (ease_media_element_get_type ())
#define EASE_MEDIA_ELEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EASE_TYPE_MEDIA_ELEMENT, EaseMediaElement))
#define EASE_MEDIA_ELEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EASE_TYPE_MEDIA_ELEMENT, EaseMediaElementClass))
#define EASE_IS_MEDIA_ELEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EASE_TYPE_MEDIA_ELEMENT))
#define EASE_IS_MEDIA_ELEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EASE_TYPE_MEDIA_ELEMENT))
#define EASE_MEDIA_ELEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EASE_TYPE_MEDIA_ELEMENT, EaseMediaElementClass))

typedef struct _EaseMediaElement EaseMediaElement;
typedef struct _EaseMediaElementClass EaseMediaElementClass;

#define EASE_TYPE_IMAGE_ELEMENT (ease_image_element_get_type ())
#define EASE_IMAGE_ELEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EASE_TYPE_IMAGE_ELEMENT, EaseImageElement))
#define EASE_IMAGE_ELEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EASE_TYPE_IMAGE_ELEMENT, EaseImageElementClass))
#define EASE_IS_IMAGE_ELEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EASE_TYPE_IMAGE_ELEMENT))
#define EASE_IS_IMAGE_ELEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EASE_TYPE_IMAGE_ELEMENT))
#define EASE_IMAGE_ELEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EASE_TYPE_IMAGE_ELEMENT, EaseImageElementClass))

typedef struct _EaseImageElement EaseImageElement;
typedef struct _EaseImageElementClass EaseImageElementClass;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _Block7Data Block7Data;

typedef enum  {
	EASE_ACTOR_CONTEXT_PRESENTATION,
	EASE_ACTOR_CONTEXT_EDITOR,
	EASE_ACTOR_CONTEXT_INSPECTOR
} EaseActorContext;

struct _EaseActor {
	ClutterGroup parent_instance;
	EaseActorPrivate * priv;
	ClutterActor* contents;
	EaseElement* element;
	EaseActorContext context;
	gboolean is_background;
};

struct _EaseActorClass {
	ClutterGroupClass parent_class;
	void (*edit) (EaseActor* self, GtkWidget* sender);
	void (*end_edit) (EaseActor* self, GtkWidget* sender);
};

struct _EaseImageActor {
	EaseActor parent_instance;
	EaseImageActorPrivate * priv;
};

struct _EaseImageActorClass {
	EaseActorClass parent_class;
};

struct _Block7Data {
	int _ref_count_;
	EaseImageActor * self;
	EaseImageElement* e;
};


static gpointer ease_image_actor_parent_class = NULL;

GType ease_actor_get_type (void) G_GNUC_CONST;
GType ease_element_get_type (void) G_GNUC_CONST;
GType ease_actor_context_get_type (void) G_GNUC_CONST;
GType ease_image_actor_get_type (void) G_GNUC_CONST;
enum  {
	EASE_IMAGE_ACTOR_DUMMY_PROPERTY
};
GType ease_media_element_get_type (void) G_GNUC_CONST;
GType ease_image_element_get_type (void) G_GNUC_CONST;
EaseImageActor* ease_image_actor_new (EaseImageElement* e, EaseActorContext c);
EaseImageActor* ease_image_actor_construct (GType object_type, EaseImageElement* e, EaseActorContext c);
EaseActor* ease_actor_construct (GType object_type, EaseElement* e, EaseActorContext c);
float ease_element_get_width (EaseElement* self);
float ease_element_get_height (EaseElement* self);
float ease_element_get_x (EaseElement* self);
float ease_element_get_y (EaseElement* self);
static void _lambda23_ (GObject* obj, GParamSpec* spec, Block7Data* _data7_);
char* ease_media_element_get_full_filename (EaseMediaElement* self);
static void __lambda23__g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self);
static Block7Data* block7_data_ref (Block7Data* _data7_);
static void block7_data_unref (Block7Data* _data7_);



/**
 * Instantiates a new ImageActor from an Element.
 * 
 * ImageActor can represent either a bitmap or vector image, as it is
 * backed by {@link Clutter.Texture}. This should be automatically
 * handled by the represented {@link Element} and Clutter.
 *
 * @param e The represented element.
 * @param c The context of this Actor (Presentation, Sidebar, Editor)
 */
#line 57 "ease-image-actor.vala"
static void _lambda23_ (GObject* obj, GParamSpec* spec, Block7Data* _data7_) {
#line 167 "ease-image-actor.c"
	EaseImageActor * self;
	ClutterActor* _tmp0_;
	char* _tmp1_;
	self = _data7_->self;
#line 57 "ease-image-actor.vala"
	g_return_if_fail (obj != NULL);
#line 57 "ease-image-actor.vala"
	g_return_if_fail (spec != NULL);
#line 58 "ease-image-actor.vala"
	g_object_set ((_tmp0_ = ((EaseActor*) self)->contents, CLUTTER_IS_TEXTURE (_tmp0_) ? ((ClutterTexture*) _tmp0_) : NULL), "filename", _tmp1_ = ease_media_element_get_full_filename ((EaseMediaElement*) _data7_->e), NULL);
#line 178 "ease-image-actor.c"
	_g_free0 (_tmp1_);
}


#line 57 "ease-image-actor.vala"
static void __lambda23__g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self) {
#line 185 "ease-image-actor.c"
	_lambda23_ (_sender, pspec, self);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static Block7Data* block7_data_ref (Block7Data* _data7_) {
	g_atomic_int_inc (&_data7_->_ref_count_);
	return _data7_;
}


static void block7_data_unref (Block7Data* _data7_) {
	if (g_atomic_int_dec_and_test (&_data7_->_ref_count_)) {
		_g_object_unref0 (_data7_->self);
		_g_object_unref0 (_data7_->e);
		g_slice_free (Block7Data, _data7_);
	}
}


#line 37 "ease-image-actor.vala"
EaseImageActor* ease_image_actor_construct (GType object_type, EaseImageElement* e, EaseActorContext c) {
#line 212 "ease-image-actor.c"
	EaseImageActor * self;
	Block7Data* _data7_;
	GError * _inner_error_ = NULL;
#line 37 "ease-image-actor.vala"
	g_return_val_if_fail (e != NULL, NULL);
#line 218 "ease-image-actor.c"
	_data7_ = g_slice_new0 (Block7Data);
	_data7_->_ref_count_ = 1;
	_data7_->e = _g_object_ref0 (e);
#line 39 "ease-image-actor.vala"
	_data7_->self = g_object_ref (self = (EaseImageActor*) ease_actor_construct (object_type, (EaseElement*) _data7_->e, c));
#line 224 "ease-image-actor.c"
	{
		char* _tmp0_;
		ClutterTexture* _tmp1_;
		ClutterTexture* _tmp2_;
		ClutterActor* _tmp3_;
#line 43 "ease-image-actor.vala"
		_tmp2_ = (_tmp1_ = g_object_ref_sink (clutter_texture_new_from_file (_tmp0_ = ease_media_element_get_full_filename ((EaseMediaElement*) _data7_->e), &_inner_error_)), _g_free0 (_tmp0_), _tmp1_);
#line 232 "ease-image-actor.c"
		if (_inner_error_ != NULL) {
			goto __catch15_g_error;
		}
#line 43 "ease-image-actor.vala"
		((EaseActor*) self)->contents = (_tmp3_ = (ClutterActor*) g_object_ref_sink (_tmp2_), _g_object_unref0 (((EaseActor*) self)->contents), _tmp3_);
#line 238 "ease-image-actor.c"
	}
	goto __finally15;
	__catch15_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
#line 47 "ease-image-actor.vala"
			fprintf (stdout, _ ("Error loading ImageActor: %s\n"), e->message);
#line 249 "ease-image-actor.c"
			_g_error_free0 (e);
		}
	}
	__finally15:
	{
#line 51 "ease-image-actor.vala"
		clutter_container_add_actor ((ClutterContainer*) self, ((EaseActor*) self)->contents);
#line 52 "ease-image-actor.vala"
		clutter_actor_set_width (((EaseActor*) self)->contents, ease_element_get_width ((EaseElement*) _data7_->e));
#line 53 "ease-image-actor.vala"
		clutter_actor_set_height (((EaseActor*) self)->contents, ease_element_get_height ((EaseElement*) _data7_->e));
#line 54 "ease-image-actor.vala"
		clutter_actor_set_x ((ClutterActor*) self, ease_element_get_x ((EaseElement*) _data7_->e));
#line 55 "ease-image-actor.vala"
		clutter_actor_set_y ((ClutterActor*) self, ease_element_get_y ((EaseElement*) _data7_->e));
#line 57 "ease-image-actor.vala"
		g_signal_connect_data ((GObject*) _data7_->e, "notify::filename", (GCallback) __lambda23__g_object_notify, block7_data_ref (_data7_), (GClosureNotify) block7_data_unref, 0);
#line 267 "ease-image-actor.c"
	}
	if (_inner_error_ != NULL) {
		block7_data_unref (_data7_);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	block7_data_unref (_data7_);
	return self;
}


#line 37 "ease-image-actor.vala"
EaseImageActor* ease_image_actor_new (EaseImageElement* e, EaseActorContext c) {
#line 37 "ease-image-actor.vala"
	return ease_image_actor_construct (EASE_TYPE_IMAGE_ACTOR, e, c);
#line 284 "ease-image-actor.c"
}


static void ease_image_actor_class_init (EaseImageActorClass * klass) {
	ease_image_actor_parent_class = g_type_class_peek_parent (klass);
}


static void ease_image_actor_instance_init (EaseImageActor * self) {
}


/**
 * {@link Actor} for images
 *
 * ImageActor can represent either a bitmap or vector image, as it is
 * backed by {@link Clutter.Texture}. This should be automatically
 * handled by the represented {@link Element} and Clutter.
 */
GType ease_image_actor_get_type (void) {
	static volatile gsize ease_image_actor_type_id__volatile = 0;
	if (g_once_init_enter (&ease_image_actor_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (EaseImageActorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) ease_image_actor_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (EaseImageActor), 0, (GInstanceInitFunc) ease_image_actor_instance_init, NULL };
		GType ease_image_actor_type_id;
		ease_image_actor_type_id = g_type_register_static (EASE_TYPE_ACTOR, "EaseImageActor", &g_define_type_info, 0);
		g_once_init_leave (&ease_image_actor_type_id__volatile, ease_image_actor_type_id);
	}
	return ease_image_actor_type_id__volatile;
}




