/* ease-undo-action.c generated by valac 0.10.0, the Vala compiler
 * generated from ease-undo-action.vala, do not modify */

/*  Ease, a GTK presentation application
    Copyright (C) 2010 Nate Stedman

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include <glib.h>
#include <glib-object.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>
#include <gobject/gvaluecollector.h>


#define EASE_TYPE_UNDO_ITEM (ease_undo_item_get_type ())
#define EASE_UNDO_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EASE_TYPE_UNDO_ITEM, EaseUndoItem))
#define EASE_UNDO_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EASE_TYPE_UNDO_ITEM, EaseUndoItemClass))
#define EASE_IS_UNDO_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EASE_TYPE_UNDO_ITEM))
#define EASE_IS_UNDO_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EASE_TYPE_UNDO_ITEM))
#define EASE_UNDO_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EASE_TYPE_UNDO_ITEM, EaseUndoItemClass))

typedef struct _EaseUndoItem EaseUndoItem;
typedef struct _EaseUndoItemClass EaseUndoItemClass;
typedef struct _EaseUndoItemPrivate EaseUndoItemPrivate;

#define EASE_TYPE_UNDO_ACTION (ease_undo_action_get_type ())
#define EASE_UNDO_ACTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EASE_TYPE_UNDO_ACTION, EaseUndoAction))
#define EASE_UNDO_ACTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EASE_TYPE_UNDO_ACTION, EaseUndoActionClass))
#define EASE_IS_UNDO_ACTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EASE_TYPE_UNDO_ACTION))
#define EASE_IS_UNDO_ACTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EASE_TYPE_UNDO_ACTION))
#define EASE_UNDO_ACTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EASE_TYPE_UNDO_ACTION, EaseUndoActionClass))

typedef struct _EaseUndoAction EaseUndoAction;
typedef struct _EaseUndoActionClass EaseUndoActionClass;
typedef struct _EaseUndoActionPrivate EaseUndoActionPrivate;

#define EASE_UNDO_ACTION_TYPE_UNDO_PAIR (ease_undo_action_undo_pair_get_type ())
#define EASE_UNDO_ACTION_UNDO_PAIR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EASE_UNDO_ACTION_TYPE_UNDO_PAIR, EaseUndoActionUndoPair))
#define EASE_UNDO_ACTION_UNDO_PAIR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EASE_UNDO_ACTION_TYPE_UNDO_PAIR, EaseUndoActionUndoPairClass))
#define EASE_UNDO_ACTION_IS_UNDO_PAIR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EASE_UNDO_ACTION_TYPE_UNDO_PAIR))
#define EASE_UNDO_ACTION_IS_UNDO_PAIR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EASE_UNDO_ACTION_TYPE_UNDO_PAIR))
#define EASE_UNDO_ACTION_UNDO_PAIR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EASE_UNDO_ACTION_TYPE_UNDO_PAIR, EaseUndoActionUndoPairClass))

typedef struct _EaseUndoActionUndoPair EaseUndoActionUndoPair;
typedef struct _EaseUndoActionUndoPairClass EaseUndoActionUndoPairClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _ease_undo_action_undo_pair_unref0(var) ((var == NULL) ? NULL : (var = (ease_undo_action_undo_pair_unref (var), NULL)))
typedef struct _EaseUndoActionUndoPairPrivate EaseUndoActionUndoPairPrivate;
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _EaseUndoActionParamSpecUndoPair EaseUndoActionParamSpecUndoPair;

struct _EaseUndoItem {
	GObject parent_instance;
	EaseUndoItemPrivate * priv;
};

struct _EaseUndoItemClass {
	GObjectClass parent_class;
	EaseUndoItem* (*apply) (EaseUndoItem* self);
	gboolean (*contains) (EaseUndoItem* self, GObject* obj);
};

struct _EaseUndoAction {
	EaseUndoItem parent_instance;
	EaseUndoActionPrivate * priv;
	GeeLinkedList* pairs;
};

struct _EaseUndoActionClass {
	EaseUndoItemClass parent_class;
};

struct _EaseUndoActionUndoPair {
	GTypeInstance parent_instance;
	volatile int ref_count;
	EaseUndoActionUndoPairPrivate * priv;
	char* property;
	GObject* object;
	GValue val;
	GType type;
};

struct _EaseUndoActionUndoPairClass {
	GTypeClass parent_class;
	void (*finalize) (EaseUndoActionUndoPair *self);
};

struct _EaseUndoActionParamSpecUndoPair {
	GParamSpec parent_instance;
};


static gpointer ease_undo_action_undo_pair_parent_class = NULL;
static gpointer ease_undo_action_parent_class = NULL;

GType ease_undo_item_get_type (void) G_GNUC_CONST;
GType ease_undo_action_get_type (void) G_GNUC_CONST;
gpointer ease_undo_action_undo_pair_ref (gpointer instance);
void ease_undo_action_undo_pair_unref (gpointer instance);
GParamSpec* ease_undo_action_param_spec_undo_pair (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void ease_undo_action_value_set_undo_pair (GValue* value, gpointer v_object);
void ease_undo_action_value_take_undo_pair (GValue* value, gpointer v_object);
gpointer ease_undo_action_value_get_undo_pair (const GValue* value);
GType ease_undo_action_undo_pair_get_type (void) G_GNUC_CONST;
enum  {
	EASE_UNDO_ACTION_DUMMY_PROPERTY
};
EaseUndoAction* ease_undo_action_new (GObject* obj, const char* prop);
EaseUndoAction* ease_undo_action_construct (GType object_type, GObject* obj, const char* prop);
EaseUndoItem* ease_undo_item_construct (GType object_type);
EaseUndoActionUndoPair* ease_undo_action_undo_pair_new (GObject* obj, const char* prop);
EaseUndoActionUndoPair* ease_undo_action_undo_pair_construct (GType object_type, GObject* obj, const char* prop);
void ease_undo_action_add (EaseUndoAction* self, GObject* obj, const char* prop);
void ease_undo_action_combine (EaseUndoAction* self, EaseUndoAction* action);
static EaseUndoItem* ease_undo_action_real_apply (EaseUndoItem* base);
void ease_undo_action_undo_pair_apply (EaseUndoActionUndoPair* self);
static gboolean ease_undo_action_real_contains (EaseUndoItem* base, GObject* obj);
enum  {
	EASE_UNDO_ACTION_UNDO_PAIR_DUMMY_PROPERTY
};
static void ease_undo_action_undo_pair_finalize (EaseUndoActionUndoPair* obj);
static void ease_undo_action_finalize (GObject* obj);



/**
 * Creates an UndoAction.
 *
 * This should be followed up with calls to add() if the action has
 * multiple properties (or someone could figure out varargs in Vala).
 *
 * @param obj The first object.
 * @param val The first property.
 */
#line 34 "ease-undo-action.vala"
EaseUndoAction* ease_undo_action_construct (GType object_type, GObject* obj, const char* prop) {
#line 152 "ease-undo-action.c"
	EaseUndoAction * self;
	EaseUndoActionUndoPair* _tmp0_;
#line 34 "ease-undo-action.vala"
	g_return_val_if_fail (obj != NULL, NULL);
#line 34 "ease-undo-action.vala"
	g_return_val_if_fail (prop != NULL, NULL);
#line 34 "ease-undo-action.vala"
	self = (EaseUndoAction*) ease_undo_item_construct (object_type);
#line 36 "ease-undo-action.vala"
	gee_abstract_collection_add ((GeeAbstractCollection*) self->pairs, _tmp0_ = ease_undo_action_undo_pair_new (obj, prop));
#line 163 "ease-undo-action.c"
	_ease_undo_action_undo_pair_unref0 (_tmp0_);
	return self;
}


#line 34 "ease-undo-action.vala"
EaseUndoAction* ease_undo_action_new (GObject* obj, const char* prop) {
#line 34 "ease-undo-action.vala"
	return ease_undo_action_construct (EASE_TYPE_UNDO_ACTION, obj, prop);
#line 173 "ease-undo-action.c"
}


/**
 * Adds an additional object/property pair.
 *
 * @param obj The first object.
 * @param val The first property.
 */
#line 45 "ease-undo-action.vala"
void ease_undo_action_add (EaseUndoAction* self, GObject* obj, const char* prop) {
#line 185 "ease-undo-action.c"
	EaseUndoActionUndoPair* _tmp0_;
#line 45 "ease-undo-action.vala"
	g_return_if_fail (self != NULL);
#line 45 "ease-undo-action.vala"
	g_return_if_fail (obj != NULL);
#line 45 "ease-undo-action.vala"
	g_return_if_fail (prop != NULL);
#line 47 "ease-undo-action.vala"
	gee_abstract_collection_add ((GeeAbstractCollection*) self->pairs, _tmp0_ = ease_undo_action_undo_pair_new (obj, prop));
#line 195 "ease-undo-action.c"
	_ease_undo_action_undo_pair_unref0 (_tmp0_);
}


/**
 * Adds all properties of the given UndoAction to this action.
 *
 * @param action An UndoAction to add properties from.
 */
#line 55 "ease-undo-action.vala"
void ease_undo_action_combine (EaseUndoAction* self, EaseUndoAction* action) {
#line 55 "ease-undo-action.vala"
	g_return_if_fail (self != NULL);
#line 55 "ease-undo-action.vala"
	g_return_if_fail (action != NULL);
#line 211 "ease-undo-action.c"
	{
		GeeIterator* _p_it;
#line 57 "ease-undo-action.vala"
		_p_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) action->pairs);
#line 57 "ease-undo-action.vala"
		while (TRUE) {
#line 218 "ease-undo-action.c"
			EaseUndoActionUndoPair* p;
#line 57 "ease-undo-action.vala"
			if (!gee_iterator_next (_p_it)) {
#line 57 "ease-undo-action.vala"
				break;
#line 224 "ease-undo-action.c"
			}
#line 57 "ease-undo-action.vala"
			p = (EaseUndoActionUndoPair*) gee_iterator_get (_p_it);
#line 57 "ease-undo-action.vala"
			gee_abstract_collection_add ((GeeAbstractCollection*) self->pairs, p);
#line 230 "ease-undo-action.c"
			_ease_undo_action_undo_pair_unref0 (p);
		}
		_g_object_unref0 (_p_it);
	}
}


/**
 * Applies the {@link UndoAction}, restoring previous settings.
 *
 * Returns an UndoAction that will redo the undo action.
 */
static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


#line 65 "ease-undo-action.vala"
static EaseUndoItem* ease_undo_action_real_apply (EaseUndoItem* base) {
#line 250 "ease-undo-action.c"
	EaseUndoAction * self;
	EaseUndoItem* result = NULL;
	self = (EaseUndoAction*) base;
#line 67 "ease-undo-action.vala"
	g_signal_emit_by_name ((EaseUndoItem*) self, "pre-apply", self);
#line 256 "ease-undo-action.c"
	{
		GeeIterator* _pair_it;
#line 68 "ease-undo-action.vala"
		_pair_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->pairs);
#line 68 "ease-undo-action.vala"
		while (TRUE) {
#line 263 "ease-undo-action.c"
			EaseUndoActionUndoPair* pair;
#line 68 "ease-undo-action.vala"
			if (!gee_iterator_next (_pair_it)) {
#line 68 "ease-undo-action.vala"
				break;
#line 269 "ease-undo-action.c"
			}
#line 68 "ease-undo-action.vala"
			pair = (EaseUndoActionUndoPair*) gee_iterator_get (_pair_it);
#line 68 "ease-undo-action.vala"
			ease_undo_action_undo_pair_apply (pair);
#line 275 "ease-undo-action.c"
			_ease_undo_action_undo_pair_unref0 (pair);
		}
		_g_object_unref0 (_pair_it);
	}
#line 69 "ease-undo-action.vala"
	g_signal_emit_by_name ((EaseUndoItem*) self, "applied", self);
#line 282 "ease-undo-action.c"
	result = _g_object_ref0 ((EaseUndoItem*) self);
#line 70 "ease-undo-action.vala"
	return result;
#line 286 "ease-undo-action.c"
}


/**
 * Returns true if this action contains a property on the specified object.
 */
#line 76 "ease-undo-action.vala"
static gboolean ease_undo_action_real_contains (EaseUndoItem* base, GObject* obj) {
#line 295 "ease-undo-action.c"
	EaseUndoAction * self;
	gboolean result = FALSE;
	self = (EaseUndoAction*) base;
#line 78 "ease-undo-action.vala"
	if (obj == NULL) {
#line 301 "ease-undo-action.c"
		result = FALSE;
#line 78 "ease-undo-action.vala"
		return result;
#line 305 "ease-undo-action.c"
	}
	{
		GeeIterator* _pair_it;
#line 79 "ease-undo-action.vala"
		_pair_it = gee_abstract_collection_iterator ((GeeAbstractCollection*) self->pairs);
#line 79 "ease-undo-action.vala"
		while (TRUE) {
#line 313 "ease-undo-action.c"
			EaseUndoActionUndoPair* pair;
#line 79 "ease-undo-action.vala"
			if (!gee_iterator_next (_pair_it)) {
#line 79 "ease-undo-action.vala"
				break;
#line 319 "ease-undo-action.c"
			}
#line 79 "ease-undo-action.vala"
			pair = (EaseUndoActionUndoPair*) gee_iterator_get (_pair_it);
#line 81 "ease-undo-action.vala"
			if (pair->object == obj) {
#line 325 "ease-undo-action.c"
				result = TRUE;
				_ease_undo_action_undo_pair_unref0 (pair);
				_g_object_unref0 (_pair_it);
#line 81 "ease-undo-action.vala"
				return result;
#line 331 "ease-undo-action.c"
			}
			_ease_undo_action_undo_pair_unref0 (pair);
		}
		_g_object_unref0 (_pair_it);
	}
	result = FALSE;
#line 83 "ease-undo-action.vala"
	return result;
#line 340 "ease-undo-action.c"
}


#line 96 "ease-undo-action.vala"
EaseUndoActionUndoPair* ease_undo_action_undo_pair_construct (GType object_type, GObject* obj, const char* prop) {
#line 346 "ease-undo-action.c"
	EaseUndoActionUndoPair* self;
	GObject* _tmp0_;
	char* _tmp1_;
	GValue _tmp2_ = {0};
	GValue _tmp3_;
#line 96 "ease-undo-action.vala"
	g_return_val_if_fail (obj != NULL, NULL);
#line 96 "ease-undo-action.vala"
	g_return_val_if_fail (prop != NULL, NULL);
#line 356 "ease-undo-action.c"
	self = (EaseUndoActionUndoPair*) g_type_create_instance (object_type);
#line 99 "ease-undo-action.vala"
	self->object = (_tmp0_ = _g_object_ref0 (obj), _g_object_unref0 (self->object), _tmp0_);
#line 100 "ease-undo-action.vala"
	self->property = (_tmp1_ = g_strdup (prop), _g_free0 (self->property), _tmp1_);
#line 103 "ease-undo-action.vala"
	self->type = g_object_class_find_property (G_OBJECT_GET_CLASS (obj), prop)->value_type;
#line 104 "ease-undo-action.vala"
	self->val = (_tmp3_ = (g_value_init (&_tmp2_, self->type), _tmp2_), G_IS_VALUE (&self->val) ? (g_value_unset (&self->val), NULL) : NULL, _tmp3_);
#line 107 "ease-undo-action.vala"
	g_object_get_property (obj, prop, &self->val);
#line 368 "ease-undo-action.c"
	return self;
}


#line 96 "ease-undo-action.vala"
EaseUndoActionUndoPair* ease_undo_action_undo_pair_new (GObject* obj, const char* prop) {
#line 96 "ease-undo-action.vala"
	return ease_undo_action_undo_pair_construct (EASE_UNDO_ACTION_TYPE_UNDO_PAIR, obj, prop);
#line 377 "ease-undo-action.c"
}


/**
 * Applies this UndoPair, restoring the property to its original value.
 *
 * The current (before restoration) value is then placed into this
 * UndoPair, converting it into a "RedoPair" of sorts.
 */
#line 116 "ease-undo-action.vala"
void ease_undo_action_undo_pair_apply (EaseUndoActionUndoPair* self) {
#line 389 "ease-undo-action.c"
	GValue temp = {0};
	GValue _tmp0_ = {0};
	GValue _tmp1_;
#line 116 "ease-undo-action.vala"
	g_return_if_fail (self != NULL);
#line 395 "ease-undo-action.c"
	g_value_init (&temp, self->type);
#line 120 "ease-undo-action.vala"
	g_object_get_property (self->object, self->property, &temp);
#line 123 "ease-undo-action.vala"
	g_object_set_property (self->object, self->property, &self->val);
#line 126 "ease-undo-action.vala"
	self->val = (_tmp1_ = G_IS_VALUE (&temp) ? (g_value_init (&_tmp0_, G_VALUE_TYPE (&temp)), g_value_copy (&temp, &_tmp0_), _tmp0_) : temp, G_IS_VALUE (&self->val) ? (g_value_unset (&self->val), NULL) : NULL, _tmp1_);
#line 403 "ease-undo-action.c"
	G_IS_VALUE (&temp) ? (g_value_unset (&temp), NULL) : NULL;
}


static void ease_undo_action_value_undo_pair_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void ease_undo_action_value_undo_pair_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		ease_undo_action_undo_pair_unref (value->data[0].v_pointer);
	}
}


static void ease_undo_action_value_undo_pair_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = ease_undo_action_undo_pair_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer ease_undo_action_value_undo_pair_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* ease_undo_action_value_undo_pair_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		EaseUndoActionUndoPair* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = ease_undo_action_undo_pair_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* ease_undo_action_value_undo_pair_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	EaseUndoActionUndoPair** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = ease_undo_action_undo_pair_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* ease_undo_action_param_spec_undo_pair (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	EaseUndoActionParamSpecUndoPair* spec;
	g_return_val_if_fail (g_type_is_a (object_type, EASE_UNDO_ACTION_TYPE_UNDO_PAIR), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer ease_undo_action_value_get_undo_pair (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, EASE_UNDO_ACTION_TYPE_UNDO_PAIR), NULL);
	return value->data[0].v_pointer;
}


void ease_undo_action_value_set_undo_pair (GValue* value, gpointer v_object) {
	EaseUndoActionUndoPair* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, EASE_UNDO_ACTION_TYPE_UNDO_PAIR));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, EASE_UNDO_ACTION_TYPE_UNDO_PAIR));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		ease_undo_action_undo_pair_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		ease_undo_action_undo_pair_unref (old);
	}
}


void ease_undo_action_value_take_undo_pair (GValue* value, gpointer v_object) {
	EaseUndoActionUndoPair* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, EASE_UNDO_ACTION_TYPE_UNDO_PAIR));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, EASE_UNDO_ACTION_TYPE_UNDO_PAIR));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		ease_undo_action_undo_pair_unref (old);
	}
}


static void ease_undo_action_undo_pair_class_init (EaseUndoActionUndoPairClass * klass) {
	ease_undo_action_undo_pair_parent_class = g_type_class_peek_parent (klass);
	EASE_UNDO_ACTION_UNDO_PAIR_CLASS (klass)->finalize = ease_undo_action_undo_pair_finalize;
}


static void ease_undo_action_undo_pair_instance_init (EaseUndoActionUndoPair * self) {
	self->ref_count = 1;
}


static void ease_undo_action_undo_pair_finalize (EaseUndoActionUndoPair* obj) {
	EaseUndoActionUndoPair * self;
	self = EASE_UNDO_ACTION_UNDO_PAIR (obj);
	_g_free0 (self->property);
	_g_object_unref0 (self->object);
	G_IS_VALUE (&self->val) ? (g_value_unset (&self->val), NULL) : NULL;
}


/**
 * Embedded class for storing object/property pairs in undo actions.
 */
GType ease_undo_action_undo_pair_get_type (void) {
	static volatile gsize ease_undo_action_undo_pair_type_id__volatile = 0;
	if (g_once_init_enter (&ease_undo_action_undo_pair_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { ease_undo_action_value_undo_pair_init, ease_undo_action_value_undo_pair_free_value, ease_undo_action_value_undo_pair_copy_value, ease_undo_action_value_undo_pair_peek_pointer, "p", ease_undo_action_value_undo_pair_collect_value, "p", ease_undo_action_value_undo_pair_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (EaseUndoActionUndoPairClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) ease_undo_action_undo_pair_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (EaseUndoActionUndoPair), 0, (GInstanceInitFunc) ease_undo_action_undo_pair_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType ease_undo_action_undo_pair_type_id;
		ease_undo_action_undo_pair_type_id = g_type_register_fundamental (g_type_fundamental_next (), "EaseUndoActionUndoPair", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&ease_undo_action_undo_pair_type_id__volatile, ease_undo_action_undo_pair_type_id);
	}
	return ease_undo_action_undo_pair_type_id__volatile;
}


gpointer ease_undo_action_undo_pair_ref (gpointer instance) {
	EaseUndoActionUndoPair* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void ease_undo_action_undo_pair_unref (gpointer instance) {
	EaseUndoActionUndoPair* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		EASE_UNDO_ACTION_UNDO_PAIR_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void ease_undo_action_class_init (EaseUndoActionClass * klass) {
	ease_undo_action_parent_class = g_type_class_peek_parent (klass);
	EASE_UNDO_ITEM_CLASS (klass)->apply = ease_undo_action_real_apply;
	EASE_UNDO_ITEM_CLASS (klass)->contains = ease_undo_action_real_contains;
	G_OBJECT_CLASS (klass)->finalize = ease_undo_action_finalize;
}


static void ease_undo_action_instance_init (EaseUndoAction * self) {
	self->pairs = gee_linked_list_new (EASE_UNDO_ACTION_TYPE_UNDO_PAIR, (GBoxedCopyFunc) ease_undo_action_undo_pair_ref, ease_undo_action_undo_pair_unref, NULL);
}


static void ease_undo_action_finalize (GObject* obj) {
	EaseUndoAction * self;
	self = EASE_UNDO_ACTION (obj);
	_g_object_unref0 (self->pairs);
	G_OBJECT_CLASS (ease_undo_action_parent_class)->finalize (obj);
}


/**
 * Generic undo item, using object/property pairs.
 */
GType ease_undo_action_get_type (void) {
	static volatile gsize ease_undo_action_type_id__volatile = 0;
	if (g_once_init_enter (&ease_undo_action_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (EaseUndoActionClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) ease_undo_action_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (EaseUndoAction), 0, (GInstanceInitFunc) ease_undo_action_instance_init, NULL };
		GType ease_undo_action_type_id;
		ease_undo_action_type_id = g_type_register_static (EASE_TYPE_UNDO_ITEM, "EaseUndoAction", &g_define_type_info, 0);
		g_once_init_leave (&ease_undo_action_type_id__volatile, ease_undo_action_type_id);
	}
	return ease_undo_action_type_id__volatile;
}




