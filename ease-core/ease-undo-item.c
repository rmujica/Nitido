/* ease-undo-item.c generated by valac 0.10.0, the Vala compiler
 * generated from ease-undo-item.vala, do not modify */

/*  Ease, a GTK presentation application
    Copyright (C) 2010 Nate Stedman

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include <glib.h>
#include <glib-object.h>


#define EASE_TYPE_UNDO_ITEM (ease_undo_item_get_type ())
#define EASE_UNDO_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EASE_TYPE_UNDO_ITEM, EaseUndoItem))
#define EASE_UNDO_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EASE_TYPE_UNDO_ITEM, EaseUndoItemClass))
#define EASE_IS_UNDO_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EASE_TYPE_UNDO_ITEM))
#define EASE_IS_UNDO_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EASE_TYPE_UNDO_ITEM))
#define EASE_UNDO_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EASE_TYPE_UNDO_ITEM, EaseUndoItemClass))

typedef struct _EaseUndoItem EaseUndoItem;
typedef struct _EaseUndoItemClass EaseUndoItemClass;
typedef struct _EaseUndoItemPrivate EaseUndoItemPrivate;

#define EASE_TYPE_UNDO_ACTION (ease_undo_action_get_type ())
#define EASE_UNDO_ACTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EASE_TYPE_UNDO_ACTION, EaseUndoAction))
#define EASE_UNDO_ACTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EASE_TYPE_UNDO_ACTION, EaseUndoActionClass))
#define EASE_IS_UNDO_ACTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EASE_TYPE_UNDO_ACTION))
#define EASE_IS_UNDO_ACTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EASE_TYPE_UNDO_ACTION))
#define EASE_UNDO_ACTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EASE_TYPE_UNDO_ACTION, EaseUndoActionClass))

typedef struct _EaseUndoAction EaseUndoAction;
typedef struct _EaseUndoActionClass EaseUndoActionClass;

struct _EaseUndoItem {
	GObject parent_instance;
	EaseUndoItemPrivate * priv;
};

struct _EaseUndoItemClass {
	GObjectClass parent_class;
	EaseUndoItem* (*apply) (EaseUndoItem* self);
	gboolean (*contains) (EaseUndoItem* self, GObject* obj);
};


static gpointer ease_undo_item_parent_class = NULL;

GType ease_undo_item_get_type (void) G_GNUC_CONST;
enum  {
	EASE_UNDO_ITEM_DUMMY_PROPERTY
};
EaseUndoItem* ease_undo_item_apply (EaseUndoItem* self);
static EaseUndoItem* ease_undo_item_real_apply (EaseUndoItem* self);
gboolean ease_undo_item_contains (EaseUndoItem* self, GObject* obj);
static gboolean ease_undo_item_real_contains (EaseUndoItem* self, GObject* obj);
EaseUndoItem* ease_undo_item_construct (GType object_type);
GType ease_undo_action_get_type (void) G_GNUC_CONST;



/**
 * Applies the {@link UndoItem}, restoring previous state.
 *
 * Returns an UndoItem that will redo the undo action.
 */
#line 41 "ease-undo-item.vala"
static EaseUndoItem* ease_undo_item_real_apply (EaseUndoItem* self) {
#line 81 "ease-undo-item.c"
	g_return_val_if_fail (self != NULL, NULL);
	g_critical ("Type `%s' does not implement abstract method `ease_undo_item_apply'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return NULL;
}


EaseUndoItem* ease_undo_item_apply (EaseUndoItem* self) {
	return EASE_UNDO_ITEM_GET_CLASS (self)->apply (self);
}


/**
 * If the UndoItem contains the specified object. {@link UndoAction}
 * overrides this in a useful way. In its base implementation, always
 * returns false.
 */
#line 48 "ease-undo-item.vala"
static gboolean ease_undo_item_real_contains (EaseUndoItem* self, GObject* obj) {
#line 100 "ease-undo-item.c"
	gboolean result = FALSE;
#line 48 "ease-undo-item.vala"
	g_return_val_if_fail (self != NULL, FALSE);
#line 104 "ease-undo-item.c"
	result = FALSE;
#line 50 "ease-undo-item.vala"
	return result;
#line 108 "ease-undo-item.c"
}


gboolean ease_undo_item_contains (EaseUndoItem* self, GObject* obj) {
	return EASE_UNDO_ITEM_GET_CLASS (self)->contains (self, obj);
}


#line 24 "ease-undo-item.vala"
EaseUndoItem* ease_undo_item_construct (GType object_type) {
#line 119 "ease-undo-item.c"
	EaseUndoItem * self;
#line 24 "ease-undo-item.vala"
	self = (EaseUndoItem*) g_object_new (object_type, NULL);
#line 123 "ease-undo-item.c"
	return self;
}


static void ease_undo_item_class_init (EaseUndoItemClass * klass) {
	ease_undo_item_parent_class = g_type_class_peek_parent (klass);
	EASE_UNDO_ITEM_CLASS (klass)->apply = ease_undo_item_real_apply;
	EASE_UNDO_ITEM_CLASS (klass)->contains = ease_undo_item_real_contains;
	/**
	 * Emitted after the item is applied.
	 */
	g_signal_new ("applied", EASE_TYPE_UNDO_ITEM, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__OBJECT, G_TYPE_NONE, 1, EASE_TYPE_UNDO_ACTION);
	/**
	 * Emitted befor the item is applied.
	 */
	g_signal_new ("pre_apply", EASE_TYPE_UNDO_ITEM, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__OBJECT, G_TYPE_NONE, 1, EASE_TYPE_UNDO_ACTION);
}


static void ease_undo_item_instance_init (EaseUndoItem * self) {
}


/**
 * Abstract base class for undo actions.
 *
 * Subclasses should override apply() and add a constructor, as well as any
 * needed data fields.
 */
GType ease_undo_item_get_type (void) {
	static volatile gsize ease_undo_item_type_id__volatile = 0;
	if (g_once_init_enter (&ease_undo_item_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (EaseUndoItemClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) ease_undo_item_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (EaseUndoItem), 0, (GInstanceInitFunc) ease_undo_item_instance_init, NULL };
		GType ease_undo_item_type_id;
		ease_undo_item_type_id = g_type_register_static (G_TYPE_OBJECT, "EaseUndoItem", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
		g_once_init_leave (&ease_undo_item_type_id__volatile, ease_undo_item_type_id);
	}
	return ease_undo_item_type_id__volatile;
}




