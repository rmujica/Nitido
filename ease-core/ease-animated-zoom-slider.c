/* ease-animated-zoom-slider.c generated by valac 0.10.0, the Vala compiler
 * generated from ease-animated-zoom-slider.vala, do not modify */

/*  Ease, a GTK presentation application
    Copyright (C) 2010 Nate Stedman

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <float.h>
#include <math.h>
#include <clutter/clutter.h>
#include <stdlib.h>
#include <string.h>


#define EASE_TYPE_ZOOM_SLIDER (ease_zoom_slider_get_type ())
#define EASE_ZOOM_SLIDER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EASE_TYPE_ZOOM_SLIDER, EaseZoomSlider))
#define EASE_ZOOM_SLIDER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EASE_TYPE_ZOOM_SLIDER, EaseZoomSliderClass))
#define EASE_IS_ZOOM_SLIDER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EASE_TYPE_ZOOM_SLIDER))
#define EASE_IS_ZOOM_SLIDER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EASE_TYPE_ZOOM_SLIDER))
#define EASE_ZOOM_SLIDER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EASE_TYPE_ZOOM_SLIDER, EaseZoomSliderClass))

typedef struct _EaseZoomSlider EaseZoomSlider;
typedef struct _EaseZoomSliderClass EaseZoomSliderClass;
typedef struct _EaseZoomSliderPrivate EaseZoomSliderPrivate;

#define EASE_TYPE_ANIMATED_ZOOM_SLIDER (ease_animated_zoom_slider_get_type ())
#define EASE_ANIMATED_ZOOM_SLIDER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EASE_TYPE_ANIMATED_ZOOM_SLIDER, EaseAnimatedZoomSlider))
#define EASE_ANIMATED_ZOOM_SLIDER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), EASE_TYPE_ANIMATED_ZOOM_SLIDER, EaseAnimatedZoomSliderClass))
#define EASE_IS_ANIMATED_ZOOM_SLIDER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EASE_TYPE_ANIMATED_ZOOM_SLIDER))
#define EASE_IS_ANIMATED_ZOOM_SLIDER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), EASE_TYPE_ANIMATED_ZOOM_SLIDER))
#define EASE_ANIMATED_ZOOM_SLIDER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EASE_TYPE_ANIMATED_ZOOM_SLIDER, EaseAnimatedZoomSliderClass))

typedef struct _EaseAnimatedZoomSlider EaseAnimatedZoomSlider;
typedef struct _EaseAnimatedZoomSliderClass EaseAnimatedZoomSliderClass;
typedef struct _EaseAnimatedZoomSliderPrivate EaseAnimatedZoomSliderPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

struct _EaseZoomSlider {
	GtkAlignment parent_instance;
	EaseZoomSliderPrivate * priv;
	gint* values;
	gint values_length1;
};

struct _EaseZoomSliderClass {
	GtkAlignmentClass parent_class;
	void (*change_zoom) (EaseZoomSlider* self, double value);
};

struct _EaseAnimatedZoomSlider {
	EaseZoomSlider parent_instance;
	EaseAnimatedZoomSliderPrivate * priv;
};

struct _EaseAnimatedZoomSliderClass {
	EaseZoomSliderClass parent_class;
};

struct _EaseAnimatedZoomSliderPrivate {
	ClutterAnimation* zoom_anim;
	gboolean _animate;
};


static gpointer ease_animated_zoom_slider_parent_class = NULL;
static ClutterAnimatableIface* ease_animated_zoom_slider_clutter_animatable_parent_iface = NULL;

GType ease_zoom_slider_get_type (void) G_GNUC_CONST;
GType ease_animated_zoom_slider_get_type (void) G_GNUC_CONST;
#define EASE_ANIMATED_ZOOM_SLIDER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), EASE_TYPE_ANIMATED_ZOOM_SLIDER, EaseAnimatedZoomSliderPrivate))
enum  {
	EASE_ANIMATED_ZOOM_SLIDER_DUMMY_PROPERTY,
	EASE_ANIMATED_ZOOM_SLIDER_ANIMATE
};
#define EASE_ANIMATED_ZOOM_SLIDER_ZOOM_TIME 100
#define EASE_ANIMATED_ZOOM_SLIDER_ZOOM_MODE ((gint) CLUTTER_EASE_IN_OUT_SINE)
EaseAnimatedZoomSlider* ease_animated_zoom_slider_new (GtkAdjustment* adjustment, gint* button_values, int button_values_length1);
EaseAnimatedZoomSlider* ease_animated_zoom_slider_construct (GType object_type, GtkAdjustment* adjustment, gint* button_values, int button_values_length1);
EaseZoomSlider* ease_zoom_slider_new (GtkAdjustment* adjustment, gint* button_values, int button_values_length1);
EaseZoomSlider* ease_zoom_slider_construct (GType object_type, GtkAdjustment* adjustment, gint* button_values, int button_values_length1);
static void ease_animated_zoom_slider_real_change_zoom (EaseZoomSlider* base, double value);
gboolean ease_animated_zoom_slider_get_animate (EaseAnimatedZoomSlider* self);
void ease_zoom_slider_change_zoom (EaseZoomSlider* self, double value);
static gboolean ease_animated_zoom_slider_real_animate_property (ClutterAnimatable* base, ClutterAnimation* animation, const char* property_name, GValue* initial_value, GValue* final_value, double progress, GValue* value);
void ease_animated_zoom_slider_set_animate (EaseAnimatedZoomSlider* self, gboolean value);
static void ease_animated_zoom_slider_finalize (GObject* obj);
static void ease_animated_zoom_slider_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void ease_animated_zoom_slider_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static int _vala_strcmp0 (const char * str1, const char * str2);



/** 
 * Creates a new AnimatedZoomSlider.
 *
 * @param adjustment The Gtk.Adjustment to use.
 * @param button_values The values that the slider should stop on when the
 * zoom in and out buttons are pressed.
 */
#line 46 "ease-animated-zoom-slider.vala"
EaseAnimatedZoomSlider* ease_animated_zoom_slider_construct (GType object_type, GtkAdjustment* adjustment, gint* button_values, int button_values_length1) {
#line 119 "ease-animated-zoom-slider.c"
	EaseAnimatedZoomSlider * self;
#line 46 "ease-animated-zoom-slider.vala"
	g_return_val_if_fail (adjustment != NULL, NULL);
#line 48 "ease-animated-zoom-slider.vala"
	self = (EaseAnimatedZoomSlider*) ease_zoom_slider_construct (object_type, adjustment, button_values, button_values_length1);
#line 125 "ease-animated-zoom-slider.c"
	return self;
}


#line 46 "ease-animated-zoom-slider.vala"
EaseAnimatedZoomSlider* ease_animated_zoom_slider_new (GtkAdjustment* adjustment, gint* button_values, int button_values_length1) {
#line 46 "ease-animated-zoom-slider.vala"
	return ease_animated_zoom_slider_construct (EASE_TYPE_ANIMATED_ZOOM_SLIDER, adjustment, button_values, button_values_length1);
#line 134 "ease-animated-zoom-slider.c"
}


/**
 * {@inheritDoc}
 *
 * If {@link animate} is set to true, this will be a smoothed transition.
 */
#line 56 "ease-animated-zoom-slider.vala"
static void ease_animated_zoom_slider_real_change_zoom (EaseZoomSlider* base, double value) {
#line 145 "ease-animated-zoom-slider.c"
	EaseAnimatedZoomSlider * self;
	self = (EaseAnimatedZoomSlider*) base;
#line 58 "ease-animated-zoom-slider.vala"
	if (self->priv->_animate) {
#line 150 "ease-animated-zoom-slider.c"
		ClutterAnimation* _tmp0_;
		GValue _tmp1_ = {0};
		GValue _tmp2_;
#line 60 "ease-animated-zoom-slider.vala"
		self->priv->zoom_anim = (_tmp0_ = clutter_animation_new (), _g_object_unref0 (self->priv->zoom_anim), _tmp0_);
#line 61 "ease-animated-zoom-slider.vala"
		clutter_animation_set_object (self->priv->zoom_anim, (GObject*) self);
#line 62 "ease-animated-zoom-slider.vala"
		clutter_animation_bind (self->priv->zoom_anim, "sliderpos", (_tmp2_ = (g_value_init (&_tmp1_, G_TYPE_DOUBLE), g_value_set_double (&_tmp1_, value), _tmp1_), &_tmp2_));
#line 160 "ease-animated-zoom-slider.c"
		G_IS_VALUE (&_tmp1_) ? (g_value_unset (&_tmp1_), NULL) : NULL;
#line 63 "ease-animated-zoom-slider.vala"
		clutter_animation_set_duration (self->priv->zoom_anim, (guint) EASE_ANIMATED_ZOOM_SLIDER_ZOOM_TIME);
#line 64 "ease-animated-zoom-slider.vala"
		clutter_animation_set_mode (self->priv->zoom_anim, (gulong) EASE_ANIMATED_ZOOM_SLIDER_ZOOM_MODE);
#line 65 "ease-animated-zoom-slider.vala"
		clutter_timeline_start (clutter_animation_get_timeline (self->priv->zoom_anim));
#line 168 "ease-animated-zoom-slider.c"
	} else {
#line 67 "ease-animated-zoom-slider.vala"
		EASE_ZOOM_SLIDER_CLASS (ease_animated_zoom_slider_parent_class)->change_zoom (EASE_ZOOM_SLIDER (self), value);
#line 172 "ease-animated-zoom-slider.c"
	}
}


#line 70 "ease-animated-zoom-slider.vala"
static gboolean ease_animated_zoom_slider_real_animate_property (ClutterAnimatable* base, ClutterAnimation* animation, const char* property_name, GValue* initial_value, GValue* final_value, double progress, GValue* value) {
#line 179 "ease-animated-zoom-slider.c"
	EaseAnimatedZoomSlider * self;
	gboolean result = FALSE;
	self = (EaseAnimatedZoomSlider*) base;
#line 70 "ease-animated-zoom-slider.vala"
	g_return_val_if_fail (animation != NULL, FALSE);
#line 70 "ease-animated-zoom-slider.vala"
	g_return_val_if_fail (property_name != NULL, FALSE);
#line 77 "ease-animated-zoom-slider.vala"
	if (_vala_strcmp0 (property_name, "sliderpos") != 0) {
#line 189 "ease-animated-zoom-slider.c"
		result = FALSE;
#line 77 "ease-animated-zoom-slider.vala"
		return result;
#line 193 "ease-animated-zoom-slider.c"
	}
#line 79 "ease-animated-zoom-slider.vala"
	g_value_set_double (value, (g_value_get_double (initial_value) * (1 - progress)) + (g_value_get_double (final_value) * progress));
#line 197 "ease-animated-zoom-slider.c"
	result = TRUE;
#line 81 "ease-animated-zoom-slider.vala"
	return result;
#line 201 "ease-animated-zoom-slider.c"
}


gboolean ease_animated_zoom_slider_get_animate (EaseAnimatedZoomSlider* self) {
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_animate;
#line 37 "ease-animated-zoom-slider.vala"
	return result;
#line 211 "ease-animated-zoom-slider.c"
}


void ease_animated_zoom_slider_set_animate (EaseAnimatedZoomSlider* self, gboolean value) {
	g_return_if_fail (self != NULL);
	self->priv->_animate = value;
	g_object_notify ((GObject *) self, "animate");
}


static void ease_animated_zoom_slider_class_init (EaseAnimatedZoomSliderClass * klass) {
	ease_animated_zoom_slider_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (EaseAnimatedZoomSliderPrivate));
	EASE_ZOOM_SLIDER_CLASS (klass)->change_zoom = ease_animated_zoom_slider_real_change_zoom;
	G_OBJECT_CLASS (klass)->get_property = ease_animated_zoom_slider_get_property;
	G_OBJECT_CLASS (klass)->set_property = ease_animated_zoom_slider_set_property;
	G_OBJECT_CLASS (klass)->finalize = ease_animated_zoom_slider_finalize;
	/**
	 * Whether or not the AnimatedZoomSlider should animate its zoom when the
	 * + and - buttons are clicked. Setting this to false will make the
	 * AnimatedZoomSlider perform identically to a {@link ZoomSlider}.
	 *
	 * Set to "true" by default.
	 */
	g_object_class_install_property (G_OBJECT_CLASS (klass), EASE_ANIMATED_ZOOM_SLIDER_ANIMATE, g_param_spec_boolean ("animate", "animate", "animate", TRUE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void ease_animated_zoom_slider_clutter_animatable_interface_init (ClutterAnimatableIface * iface) {
	ease_animated_zoom_slider_clutter_animatable_parent_iface = g_type_interface_peek_parent (iface);
	iface->animate_property = ease_animated_zoom_slider_real_animate_property;
}


static void ease_animated_zoom_slider_instance_init (EaseAnimatedZoomSlider * self) {
	self->priv = EASE_ANIMATED_ZOOM_SLIDER_GET_PRIVATE (self);
	self->priv->_animate = TRUE;
}


static void ease_animated_zoom_slider_finalize (GObject* obj) {
	EaseAnimatedZoomSlider * self;
	self = EASE_ANIMATED_ZOOM_SLIDER (obj);
	_g_object_unref0 (self->priv->zoom_anim);
	G_OBJECT_CLASS (ease_animated_zoom_slider_parent_class)->finalize (obj);
}


/**
 * An animated {@link ZoomSlider}.
 *
 * AnimatedZoomSlider smoothly animates (with ClutterAnimation)
 * when the + or - buttons are pressed.
 */
GType ease_animated_zoom_slider_get_type (void) {
	static volatile gsize ease_animated_zoom_slider_type_id__volatile = 0;
	if (g_once_init_enter (&ease_animated_zoom_slider_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (EaseAnimatedZoomSliderClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) ease_animated_zoom_slider_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (EaseAnimatedZoomSlider), 0, (GInstanceInitFunc) ease_animated_zoom_slider_instance_init, NULL };
		static const GInterfaceInfo clutter_animatable_info = { (GInterfaceInitFunc) ease_animated_zoom_slider_clutter_animatable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType ease_animated_zoom_slider_type_id;
		ease_animated_zoom_slider_type_id = g_type_register_static (EASE_TYPE_ZOOM_SLIDER, "EaseAnimatedZoomSlider", &g_define_type_info, 0);
		g_type_add_interface_static (ease_animated_zoom_slider_type_id, CLUTTER_TYPE_ANIMATABLE, &clutter_animatable_info);
		g_once_init_leave (&ease_animated_zoom_slider_type_id__volatile, ease_animated_zoom_slider_type_id);
	}
	return ease_animated_zoom_slider_type_id__volatile;
}


static void ease_animated_zoom_slider_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	EaseAnimatedZoomSlider * self;
	self = EASE_ANIMATED_ZOOM_SLIDER (object);
	switch (property_id) {
		case EASE_ANIMATED_ZOOM_SLIDER_ANIMATE:
		g_value_set_boolean (value, ease_animated_zoom_slider_get_animate (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void ease_animated_zoom_slider_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	EaseAnimatedZoomSlider * self;
	self = EASE_ANIMATED_ZOOM_SLIDER (object);
	switch (property_id) {
		case EASE_ANIMATED_ZOOM_SLIDER_ANIMATE:
		ease_animated_zoom_slider_set_animate (self, g_value_get_boolean (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static int _vala_strcmp0 (const char * str1, const char * str2) {
	if (str1 == NULL) {
		return -(str1 != str2);
	}
	if (str2 == NULL) {
		return str1 != str2;
	}
	return strcmp (str1, str2);
}




